<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>[base]</title>
	<style>
		h1,h2, h3 {
			padding-left: 20px;
		}
		html {
			font-family: -system-ui, system-ui;
			margin: 0;
			padding: 0;
		}
		div {
			display: grid;
			margin-bottom: 5px;
			margin-top: 8px;
			border: solid lightgray 1px;
			border-radius: 10px;
		}
		textarea {
			border-radius: 10px 10px 10px 10px;
			resize: none;
			outline: orange 2px;
			padding: 15px 20px 15px 20px;
			color: orange;
			display: grid;
		}
		table {
			display: grid;
		}
		table input {
			margin: 0;
		}
		div.flashcard {
			background: white;
			width: 100%;
		}
		code {
			color: lightblue;
			font-size: 10px;
			float: right;
		}
		h2, h3 {
			background: rgba(180, 200, 200, .5);
			color: darkgray;
			margin-left: 10px;
			padding-left: 5px;
			display: table-row;
			margin-top: 0px;
			margin-left: 0px;
			padding: 20px 0px 20px 0px;
			border-radius: 10px 10px 0px 0px;
			border-bottom: solid gray 1px;
		}
		p {
			padding-left: 0.5em;
			padding-right: 0.5em;
			padding-top: 0;
			padding-bottom: 0;
			border-radius: 10px;
		}
		input[type="submit"] {
			background: white;
			opacity: 60%;
			border-radius: 18px;
			padding: .5em;
			display: grid
			margin: 0.5em 1em 0.5em 1em;
			border: solid lightgray 0.25px;
		}
		time {
			font-family: monospaced system-ui, bold;
		}
		input[type="color"] {
			margin: 1em;
			height: 64px;
			width: 64px;
			border-radius: 0px;
		}
		input[type="color"]:active {
			border-radius: 10px;
		}
		input[type="color"]::-webkit-color-swatch-wrapper {
			padding: 10px;
			margin: 0px;
		}
		input[type="color"]::-webkit-color-swatch {
			margin: 0px;
			padding: 10px;
		}
		ul {
			list-style-type: none;
			font-family: arial;
		}
		.message-container {
			display: flex;
			align-items: center;
			border: none;
		}
		#messageInput {
			flex-grow: 1;
			border: none;
		}
		#messageInput:focus {
			outline: none;
		}
		input[type="submit"] {
			border: none;
		}
		button#sendButton {
			margin-right: 5px;
		}
		.comments {
			margin-top: 0;
			margin-bottom: 0;
			margin-left: 10px;
			margin-right: 10px;
		}
		.comments {
			padding: 0.5em;
			boder: none;
		}
		code {
			border: none;
			color: lightgray;
		}
		#likes::after {
			content: " likes";
		}
		#comment_label::before {
			content: "comments: "
		}
		.comments code {
			padding-left: 10px;
			padding-right: 10px;
			border-radius: 0px;
			border-top: .5px solid lightgray;
			border-bottom: .5px solid lightgray;
			border-left: 1px solid gray;
			border-right: 1px solid gray;
			background: dodgerblue;
			font-family: system-ui;
			font-size: 80%;
			color: white
		}
		.comments code:hover {
			color: lightgray;
			outline: skyblue 2px;
		}
		.comments code:first-child {
			border-radius: 5px 5px 0px 0px;
		}
		.comments code:last-child {
			border-radius: 0px 0px 5px 5px;
		}
		time:hover {
			display: flex;
		}
		time {
			display: noone;
		}
		
	</style>
	<script>
		function users_db (user_array) {
			let db;
			let store;
			let db_request = window.indexedDB.open('users', 3)
			db_request.addEventListener('success', (event) => {
				console.log("db request success", event)
				db = event.target.result
				const tx = db.transaction("all", "readwrite")
				store = tx.objectStore("all")
				user_array.forEach((user) => {
					store.add(user)
				})
			})
			db_request.addEventListener("upgradeneeded", (event) => {
				console.log("db upgrade needed", event)
				db = event.target.result
				if (!db.objectStoreNames.contains("all")) {
					store = db.createObjectStore("all", {keyPath: "id"})
				}
				store.transaction.addEventListener("complete", (ev) => {
					const tx = db.transaction("all", "readwrite")
					store = tx.objectStore("all")
					user_array.forEach((user) => {
						store.add(user)
					})
				})
			})
			db_request.addEventListener("error", (error) => {
				console.log("db request open error", error)
			})
		}
		function users_db_insert_user (user) {
			let db;
			let store;
			let db_request = window.indexedDB.open("users")
			db_request.addEventListener("success", (event) => {
				db = event.target.result
				const tx = db.transaction("all", "readwrite")
				store = tx.objectStore("all")
				const addUserRequest = store.add(user)
				addUserRequest.addEventListener("success", () => {
					console.log("user added to idb users[all] ok")
				})
				addUserRequest.addEventListener("error", (error) => {
					console.error("add user to users.all error,", error)
				})
				tx.addEventListener("complete", () => {
					db.close()
				})
			})
			db_request.addEventListener("upgradeneeded", (event) => {
				db = event.target.result
			})
			db_request.addEventListener("error", (error) => {
				console.log("user insert idb error!", error)
			})
		}
		async function users_db_get_user (user_id) {
			return new Promise ((resolve, reject) => {
				let db;
				let store;
				let db_request = window.indexedDB.open("users")
				db_request.addEventListener("success", (event) => {
					db = event.target.result
					const tx = db.transaction("all", "readonly")
					store = tx.objectStore("all")
					const get_request = store.get(user_id)
					get_request.addEventListener("success", () => {
						//console.log('success get single user', get_request)
						resolve(get_request.result)
					})
					get_request.addEventListener("error", (error) => {
						console.error("idb get single user error", user_id, error)
					})
					tx.addEventListener("complete", () => {
						//console.log('completed.',get_request.result)
						return get_request.result
						db.close()
					})
				})
				db_request.addEventListener("error", (error) => {
					console.log("idb error to get user", error)
					reject("idb open error on get one")
				})
			})
		}
		async function users_db_batch_names (user_ids) {
			let db;
			let store;
			let request = window.indexedDB.open("users")
			request.addEventListener("success", (event) => {
				db = event.target.result
				const tx = db.transaction("all", "readonly")
				store = tx.objectStore("all")
				const records = user_ids.map((id) => {
					new Promise((resolve) => {
						const tx_req = store.get(id)
						tx_req.addEventListener("success", () => {
							resolve([id, request.result])
						})
						tx_req.addEventListener("error", () => {
							resolve([id, null])
						})
					})
				})
			})
					console.log(records)
					const results = await Promise.all(records)
					const records_obj = results.reduce((acc, [id, record]) => {
						acc[id] = record
						return acc
					}, {})
					return records_obj
			request.addEVentListener("error", (error) => {
				console.error("idb error in users_db_batch_names", error)
			})
		}
		function comment_btn_click (event) {
			console.log(event)
			event.target.outerHTML = `
			<div class='comment-textarea message-container'>
				<input id="messageInput" placeholder="comment ..." type="search" >
				<button id="sendButton">&#x2191;</button>
			</div>
			`
			document.body.querySelector("button#sendButton").addEventListener("click", (e) => {
				console.log(e.target.parentElement)
				let comment = e.target.parentElement.querySelector("input[type='search']").value
				let post_id = e.target.parentElement.parentElement.querySelector("h5").textContent
				let user_id = window.localStorage.getItem("id") 
				const body = {
					action: "comment",
					user_id: user_id,
					post_id: post_id,
					comment: comment
				}
				// also send body to comment table comment objectStore here!
				console.log(body)
				window.socket.send(JSON.stringify(body))
				e.target.parentElement.querySelector("input[type='search']").value = ''
				//e.target.parentElement.remove()
			})
		}
		function like_btn_click (event) {
			console.log(event, event.target)
			event.target.setAttribute("disabled", "true")
			event.target.value = ""
			let msg = {
				action: "like",
				user_id: window.localStorage.getItem("id"),
				post_id: event.target.parentElement.querySelector("h5").textContent
			}
			window.socket.send(JSON.stringify(msg))
		}
		function prepend_new_post (post) {
			/* make post */
			let div = document.createElement('div')
			div.setAttribute('class', 'flashcard')
			let name = document.createElement('h2')
			name.textContent = post.name
			div.appendChild(name)
			let text = document.createElement('p')
			text.textContent = post.text
			div.appendChild(text)

			if (post.color) {
				name.style.color = post.color
			}

			let time = document.createElement('time')
			time.innerHTML = '0' 
			div.appendChild(time)

			let post_id = document.createElement('h5')
			post_id.setAttribute('class', 'post_id')
			post_id.setAttribute('data-postid', post.post_id)
			post_id.textContent = post.post_id
			post_id.style.display = "none"
			div.appendChild(post_id)

			let likes = document.createElement('p')
			likes.setAttribute('id', 'likes')
			likes.textContent = '0'
			div.appendChild(likes)

			let likedby = document.createElement('ul')
			likedby.setAttribute('class', 'userlist')
			div.appendChild(likedby)

			let comments = document.createElement("div")
			comments.setAttribute("class", "comments")
			comments.setAttribute("data-postid", post.post_id)
			div.appendChild(comments)	

			let like_btn = document.createElement('input')
			like_btn.setAttribute("type", "button")
			like_btn.setAttribute("value", "like")
			like_btn.addEventListener("click", like_btn_click)


			div.appendChild(like_btn)

			let comment_btn = document.createElement('input')
			comment_btn.setAttribute('type', 'button')
			comment_btn.setAttribute('value', 'comment')
			comment_btn.addEventListener('click', comment_btn_click)
			div.appendChild(comment_btn)


			let selection = document.body.querySelector("#post-aggregation").firstElementChild
			document.body.querySelector("#post-aggregation").insertBefore(div, selection)
		}

		document.addEventListener('DOMContentLoaded', (event) => {
			fetch('/base/stat', {
				method: "get",
				headers: {
					"content-type": "application/json"
				}
			}).then(res => res.json())
			.then((data) => {
				console.log('base stat', data.users)
				users_db(data.users)
				if (!window.localStorage.getItem("id")) {
						let localname = window.localStorage.getItem("name")
						data.users.forEach((user) => {
							if (user.name === localname) {
								console.log("found you!", user)
								window.localStorage.setItem("id", user.id)
							}
						})
					}
			})
		})

		document.addEventListener('DOMContentLoaded', (event) => {
			window.socket = new WebSocket('wss:/localhost/latest')
			window.socket.addEventListener('open', (event) => {
				console.log('socket open', event)
			})
			window.socket.addEventListener('message', (event) => {
				let post = JSON.parse(event.data)
				if (post.action === "post") {
					prepend_new_post(post)
					/* create a {id: post.post_id comments: []} record in the comments comments objectStore and database, respectively. :) */
					let request = window.indexedDB.open("comments")
					request.onerror = function (error) {
						console.error("request e1 @ prepense idb insert err", error)
					}
					request.onsuccess = function (event) {
						let db = event.target.result
						let tx = db.transaction("comments", "readwrite")
						let store = tx.objectStore("comments")
						const put_req = store.put({id: post.post_id, comments: []})
						put_req.onerror = (error) => {
							console.error(error)
						}
						put_req.onsuccess = (event) => {
							console.log('put result', put_req.result)
						}
					}
				}
				else if (post.action === "like") {
					console.log('like', post)
					let relevant_post = document.body.querySelector("[data-postid='"+post.post_id+"']")
					relevant_post.parentElement.querySelector("#likes").textContent = parseInt(relevant_post.parentElement.querySelector("#likes").textContent) + 1
					let li = document.createElement('li')
					// here, check idb and turn a user_id to a name
					/* create a {id: post.post_id comments: []} record in the comments comments objectStore and database, respectively. :) */
					let prom = users_db_get_user(+post.user_id)
					prom.then((msg) => {
						li.innerHTML = msg.name
						li.setAttribute("data-userid", post.user_id)
					})
					relevant_post.parentElement.querySelector(".userlist").appendChild(li)
				}
				else if (post.action === "comment") {
					// CO
					console.log('COMMENT', post)
					let relevant_post = document.body.querySelector("[data-postid='"+post.post_id+"']")
					const p2 = users_db_get_user(+post.user_id)
						.then((_p) => {
							console.log('_p',_p.name)

							const entry_node = relevant_post.parentElement.querySelector("h6").children[0]
							let comment = document.createElement("code")
							comment.textContent = _p.name + ": " + post.comment
							comment.setAttribute("data-timestamp", Date.parse(Date.now()-Date.parse(post.created_at)))
							let ti = document.createElement("time")
							const n = Date.now() - Date.parse(post.created_at)
							ti.textContent = format_time(parseInt(n))
							ti.style.color = "orange"
							ti.style.float = "right"
							ti.setAttribute("class", "post_timer")
							
							comment.appendChild(ti)
							let request = window.indexedDB.open("comments")
							request.onerror = function (err) {
								console.error("idb open err1", err)
							}
							request.onsuccess = function (event) {
								let db = event.target.result
								let tx = db.transaction("comments", "readwrite")
								let store = tx.objectStore("comments")
								let storeRequest = store.getAll()
								storeRequest.onsuccess = function (ev) {
									console.log("store request success callback, ev: ", ev.result, storeRequest.result, tx, store)
									let sett = storeRequest.result
									sett.forEach((record) => {
										console.info(record.id, post.post_id, record.comments)
										if (record.id === +post.post_id) {
											record.comments.push({
												comment_id: +post.comment_id,
												post_id: +post.post_id,
												user_id: +post.user_id,
												comment: post.comment,
												created_at: post.created_at
											})
											console.warn(record.comments)
											const reqPut = store.put({id:  +post.post_id, comments: record.comments})
											console.warn(reqPut, 'reqPut')
										}
									})
								}
							}
							

							entry_node.append(comment)
							// insert comment into comment.objectStore("comment") with id post.post_id
							
						})
				}
			})
			window.socket.addEventListener('close', () => {
				console.log('socket closed!')
			})
			let name = window.localStorage.getItem("name")+' logged in'
			let code = document.createElement("code")
			code.textContent = name
			document.body.querySelector("nav").appendChild(code)

				event.preventDefault()
				const body = {
					name: window.localStorage.getItem("name"),
					text: document.querySelector("textarea").value,
					color: document.querySelector("input[type='color']").value.toString()
				}
					fetch("/latest", {
						method: "get",
						headers: {
							"content-type": "application/json"
						},
					}).then(data => data.json())
						.then((res) => {
							console.log(res.posts)
								console.log(res.posts.length)
								res.posts.forEach((post) => {
								// create idb database "posts" with index post_id and user_id
								// add index to comments database [objectStore] 
								// write a function to put one post record in the objectStore
								fetch_comments_by_postid(post.post_id)
								let node = document.createElement('div')
								node.setAttribute('class', 'flashcard')
								let nametag = document.createElement("h3")
								nametag.textContent = post.name
								node.appendChild(nametag)
								let txtbody = document.createElement('p')
								txtbody.textContent = post.text
								node.appendChild(txtbody)

								let ts = document.createElement('time')
								ts.setAttribute("data-timestamp", post.created_at)
								ts.innerHTML = format_time(post.created_at)

								if (post.color) {
									nametag.style.color = post.color
								}

								let like_btn = document.createElement('input')
								like_btn.setAttribute('type', 'button')
								like_btn.setAttribute('value', 'like')
								like_btn.setAttribute('id', 'like_btn')
								like_btn.addEventListener('click', like_btn_click)

								let comment_btn = document.createElement('input')
								comment_btn.setAttribute('type', 'button')
								comment_btn.setAttribute('value', 'comment')
								comment_btn.setAttribute('id', 'comment_btn')
								comment_btn.addEventListener('click', comment_btn_click)
								node.appendChild(comment_btn)


								let post_id = document.createElement('h5')
								post_id.textContent = post.post_id
								post_id.style.display = "none"
								post_id.setAttribute("data-postid", post.post_id)
								node.appendChild(like_btn)
								
								if (post.user_ids_liked) {
									let post_likes = document.createElement('p')
									post_likes.setAttribute('id', 'likes')
									post_likes.textContent = post.user_ids_liked.length
									node.appendChild(post_likes)
									let liked_by = document.createElement('ul')
									liked_by.setAttribute('class', 'userlist')
									post.user_ids_liked.forEach((id) => {
										//there	
										const dbreq = users_db_get_user(id)
										dbreq.then((record) => {
											let li = document.createElement("li")
											li.innerHTML = record.name
											li.setAttribute('data-userid', id)
											liked_by.appendChild(li)
										})
									})
									post.user_ids_liked.forEach((id) => {
										if (id === +window.localStorage.getItem("id")) {
											node.querySelector('#like_btn').setAttribute('disabled', 'true')
										}
									})
									node.append(liked_by)
								}
								//labell
								let comment_label = document.createElement("h6")
								comment_label.setAttribute("id", "comment_label")
								// here, find the number of comments for post.post_id
								let db;
								let store;
								const request = window.indexedDB.open("comments")
								request.addEventListener("error", (error) => {
									console.error("could not open comments db")
								})
								request.addEventListener("success", (e) => {
									db = e.target.result
									const tx = db.transaction("comments", "readonly")
									store = tx.objectStore("comments")
									const store_req = store.get(post.post_id)
									store_req.addEventListener("success", () => {
										try {
											if (store_req.result.comments) {
												comment_label.textContent = store_req.result.comments.length
												let comments_div = document.createElement("div")
												comment_label.append(comments_div)
												comments_div.setAttribute("class", "comments")
												store_req.result.comments.forEach((comment) => {
													console.warn(comment)
													let author = document.createElement('code')
													let prom = users_db_get_user(+comment.user_id) 
														prom.then((a) => {
															author.textContent = a.name+': '+comment.comment
															author.setAttribute("data-timestamp", comment.created_at)
															author.setAttribute("class", "comment-row")
															author.addEventListener("mouseleave", (event) => {
																event.target.parentElement.querySelector("time").style.display = "none"
															})
															author.addEventListener("mouseenter", (event) => {
																event.target.parentElement.querySelector("time").style.display = "table-row"
															})
														})
													comments_div.appendChild(author)
												})	
												console.log(store_req.result)
												
											}
										}
										catch (e) {
											console.error('comments store_req error e', e)
											comment_label.textContent = 0
										}
									})
								})

								node.appendChild(comment_label)
								
								node.appendChild(post_id)
								node.appendChild(like_btn)
								node.appendChild(comment_btn)

								let dt = document.createElement('time')
								function dtupdate () {
									Array.from(document.querySelectorAll('time')).forEach((element) => {
										dt.textContent = Math.round((Date.now() - new Date(post.created_at) ))
										dt.textContent = format_time (dt.textContent)
									})
								}
								let interval = setInterval(dtupdate, 1000)

								node.appendChild(dt)
								document.body.querySelector('#post-aggregation').append(node)
							})
						})
				})
				function format_time (time) {
					let seconds = Math.floor(time/1000)
					let minutes = Math.floor(seconds/60)
					let hours = Math.floor(minutes/60)
					let days = Math.floor(hours / 24) 

					seconds = seconds % 60
					minutes = minutes % 60
					hours = hours % 24
					const padWithZeroes = (number) => (number < 10 ? `0${number}` : number)
					return `${days}d ${padWithZeroes(hours)}:${padWithZeroes(minutes)}:${padWithZeroes(seconds)}`
				}

				document.addEventListener('DOMContentLoaded', (event) => {
					document.addEventListener("submit", (e) => {
						e.preventDefault()
					})
					document.body.querySelector("textarea").addEventListener("input", (event) => {
						if (document.body.querySelector("textarea").value.length > 0) {
							document.body.querySelector("input[type='submit']").removeAttribute('disabled')
						}
						else {
							document.body.querySelector("input[type='submit']").setAttribute('disabled', true)
						}
					})
					document.body.querySelector("input[type='submit']").addEventListener('click', (e) => {
						const bod = {
							action: "post",
							name: document.body.querySelector("code").textContent.split(' ')[0],
							text: document.body.querySelector("textarea").value,
							color: document.body.querySelector("input[type='color']").value.toString()
						}

						document.body.querySelector("textarea").value = ''
						document.body.querySelector("input[type='submit']").setAttribute("disabled", "true")
						document.body.querySelector('textarea').focus()

						// here we send a new message to the live_connections set
						window.socket.send(JSON.stringify(bod))
						fetch('/base', {
							method: "post",
							headers: {
								"content-type": "application/json"
							},
							body: JSON.stringify(bod)
							})
						})
				})
	</script>
	<script>
		 function fetch_comments_by_postid (post_id) {
			fetch("/comments/"+post_id, {
				method: "get",
				headers: {
					"content-type": "application/json"
				}
			}).then(res => res.json())
				.then((data) => {
					//console.log("posts for route",post_id, data)
					// there 2
					if (data.length === 0) {
						data = {post_id: post_id, comments: []}
						//console.log(data)
					}
					else {
						for (let d of data) {
							const interactionDBRequest = window.indexedDB.open("comments")
							interactionDBRequest.addEventListener("success", (r) => {
								const db = r.target.result
								let txn = db.transaction("comments", "readwrite")
								let store = txn.objectStore("comments")
								store.put({id: post_id, comments: data}).onsuccess = function () {
									//console.log('added comment to comments db comments object store ok')
									db.close()
								}
							})
							interactionDBRequest.addEventListener("error", (error) => {
								console.error ("interactionDBRequest to insert rows failed")
							})
						}
					}
				})
			}
			function insertComments (post_id,arr) {
				let store;
				let db;
				let tx;
				let req = window.indexedDB.open("comments")
				req.addEventListener("success", (e) => {
					db = e.target.result
					tx = db.transaaction("comments", "readwrite")
					store = tx.objectStore("comments")
					store.put({id: post_id, comments: arr}).onsuccess = function () {
						db.close()
					}
					tx.addEventListener("success", () => {
						console.log("tx success!!")
					})
				})
				req.addEventListener("error", (e) => {
					console.error("error idb ", e)
				})
			}

			window.addEventListener("load", (event) => {
				const interactionDB = window.indexedDB.open("comments", 2)
				let db;
				let store;
				interactionDB.addEventListener("success", (e) => {
					console.info("comments for interaction db open success", e)
					db = e.target.result
					let tx = db.transaction("comments", "readwrite")
					console.log(tx)
					store = tx.objectStore("comments")
					console.log('db success', tx, store)
					db.close()
				})
				interactionDB.addEventListener("upgradeneeded", (e) => {
					console.info("ineractionDB open upgrade neede event handler evocation!")
					db = e.target.result
					if (!db.objectStoreNames.contains("comments")) {
						db.createObjectStore("comments", {keyPath: 'id'})
						console.log('created comments object store')
					}
				})
				interactionDB.addEventListener("error", (error) => {
					console.error("idb ineraction db store error", error)
				})

				console.info("load", event)
			})



	</script>
</head>
<body>
	<nav>
		<a href="/">logout</a>
	</nav>
	<br />
	<table>
			<form action="/base" method="post">
				<textarea name="textarea" placeholder="post!"></textarea>
				<br />
				<input name="color" type="color" />
				<input type="submit" value="post" disabled />
			</form>
	</table>
	<section id="post-aggregation"></section>
</body>
</html>
